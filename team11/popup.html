<!--
=================================================
a lot here is chatGPT because i didnt have the basics of OUR game
so these functions / functionalities will ahve to be implemented into OUR game
=================================================
-->
<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ica Väst</title>
  <style>
    :root{
      --bg:#0f172a;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --brand:#38bdf8;
    }
    html, body { height:100%; }
    body{
      margin:0;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color:var(--text);
      background:#0f172a;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding:24px;
    }

    /* Simple status bar with four pills (counters) */
    .status{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      background:rgba(255,255,255,.04);
      border:1px solid #233046;
      border-radius:12px;
      padding:10px 12px;
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      background:#0a1a33;
      border:1px solid #22304a;
      color:#bfdbfe;
      font-weight:700;
    }

    /* Toast container */
    .toasts {
      position: fixed;
      right: 16px;
      bottom: 16px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      z-index: 50;
    }

    /* Auto-resizing chat bubble toast */
    .toast {
      position: relative;
      width: clamp(280px, 32vw, 380px);
      min-height: 110px;

      background: url('./assets/chatbubble.png') no-repeat 0 0 / 100% 100%;
      border: none;
      box-shadow: none;

      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;

      padding: 16px 44px 22px 24px;

      color: #000;
      font-weight: 600;
      font-size: 14px;
      line-height: 1.35;
      white-space: normal;
      word-wrap: break-word;

      transition: opacity .25s ease, transform .25s ease;
    }
    .toast strong { display:inline; font-weight:700; }
    .toast.is-hiding { opacity:0; transform: translateY(6px); }

    /* Close button that auto-fits via percentages */
    .toast .x {
      position: absolute;
      top: 25%;
      right: 30%;
      background: transparent;
      border: none;
      color: #000;
      font-size: 14px;
      line-height: 1;
      cursor: pointer;
      padding: 2px;
      border-radius: 50%;
    }
    .toast .x:hover { background: rgba(0,0,0,0.05); }

    /* Endgame modal*/
    .modal{position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:60}
    .modal.open{display:flex}
    .modal .box{
      width:min(520px, 92vw);
      background:linear-gradient(180deg,#0d1a34,#0a1327);
      border:1px solid #25314a;
      border-radius:18px;
      padding:18px
    }
    .modal .box h3{margin:0 0 6px}
    .modal .box p{margin:0 0 16px; color:var(--muted)}
    .modal .actions{display:flex; gap:10px; justify-content:flex-end}
  </style>
</head>
<body>

  <!-- Only the counters (your responsibility) -->
  <div>
    <div class="status" id="statusBar">
      <span class="pill" id="progressPill">0 / 10 klara</span>
      <span class="pill" id="firstTryPill">Rätt: 0</span>
      <span class="pill" id="mistakesPill">Misstag: 0</span>
      <span class="pill" id="targetPill">Tröskel: 8 / 10</span>
    </div>

    <!-- Optional tiny demo controls (remove if not needed in your integration) -->
    <div class="controls">
      <button id="demoCorrect">Simulera Rätt</button>
      <button id="demoWrong">Simulera Fel</button>
      <button id="demoReset">Reset</button>
    </div>
  </div>

  <!-- Toasts container (for popup bubbles) -->
  <div class="toasts" id="toasts"></div>

  <!-- Endgame modal -->
  <div class="modal" id="endModal" role="dialog" aria-modal="true" aria-labelledby="endTitle">
    <div class="box">
      <h3 id="endTitle">Klart!</h3>
      <p id="endMsg">&nbsp;</p>
      <div class="actions">
        <button id="btnPlayAgain">Spela igen</button>
        <button id="btnMainMenu">Till huvudmenyn</button>
      </div>
    </div>
  </div>

  <script>
    // ---------------------------------------------
    // PUBLIC API (attach to window.Game)
    // ---------------------------------------------
    (function(){
      // --- Config ---
      const TARGET_TOTAL = 10;
      const WIN_THRESHOLD = Math.ceil(TARGET_TOTAL * 0.8); // 8/10

      // Small demo bank (you can supply your own externally)
      const FOOD_BANK = [
        { id:'apple',   sv:'äpple' },
        { id:'banana',  sv:'banan' },
        { id:'bread',   sv:'bröd' },
        { id:'milk',    sv:'mjölk' },
        { id:'flour',   sv:'mjöl' },
        { id:'cheese',  sv:'ost' },
        { id:'coffee',  sv:'kaffe' },
        { id:'candy',   sv:'godis' },
        { id:'yoghurt', sv:'yoghurt' },
        { id:'egg',     sv:'ägg' },
        { id:'orange',  sv:'apelsin' },
        { id:'pear',    sv:'päron' },
        { id:'tomato',  sv:'tomat' },
        { id:'cucumber',sv:'gurka' },
        { id:'water',   sv:'vatten' },
        { id:'tea',     sv:'te' },
        { id:'chocolate',sv:'choklad' },
        { id:'meat',    sv:'kött' },
        { id:'fish',    sv:'fisk' },
        { id:'rice',    sv:'ris' }
      ];

      // --- State (no UI layout dependencies) ---
      let game = null;

      // --- DOM refs for counters & popups ---
      const progressPill = document.getElementById('progressPill');
      const firstTryPill = document.getElementById('firstTryPill');
      const mistakesPill = document.getElementById('mistakesPill');
      const targetPill   = document.getElementById('targetPill');
      const toastsEl     = document.getElementById('toasts');
      const endModal     = document.getElementById('endModal');
      const endMsg       = document.getElementById('endMsg');

      document.getElementById('btnPlayAgain').addEventListener('click', () => { endModal.classList.remove('open'); newGame(true); });
      document.getElementById('btnMainMenu').addEventListener('click', () => {
          window.location.href = '../index.html'; // Adjust path if needed
        });

      // --- Utilities ---
      function pickRandom(arr, n){
        const copy = [...arr];
        const out = [];
        while(n-- > 0 && copy.length){
          out.push(copy.splice(Math.floor(Math.random()*copy.length),1)[0]);
        }
        return out;
      }
      function renderStatus(){
        progressPill.textContent = `${game.completed} / ${game.total} klara`;
        firstTryPill.textContent = `Rätt: ${game.firstTryCorrectCount}`;
        mistakesPill.textContent = `Misstag: ${game.mistakes}`;
        targetPill.textContent   = `Tröskel: ${game.winThreshold} / ${game.total}`;
      }
// ---------------------------------------------
   // GAME LOGIC
   // ---------------------------------------------
   function onPick(pickedId){
     const ix = game.orderIndex;
     const current = game.words[ix];
     const st = game.perItemState[ix];
     const correct = pickedId === current.id;


     if(correct){
       toast(`Bra jobbat, du hittade <strong>${current.sv}</strong>`, 'success');
       if(st.firstTry) game.firstTryCorrectCount += 1;
       st.done = true;
       game.completed += 1;
       nextItem();
     } else {
       toast('Försök igen!', 'error');
       if(st.firstTry){
         st.firstTry = false; // no longer eligible for first-try credit
         game.mistakes += 1;
         renderStatus();
       } else {
         game.mistakes += 1; renderStatus();
       }
     }
     renderList();
   }


   function nextItem(){
     if(game.completed >= TARGET_TOTAL){
       endGame();
       return;
     }
     // advance to next not-done index
     let next = game.orderIndex + 1;
     while(next < TARGET_TOTAL && game.perItemState[next].done){ next++; }
     // if we wrapped past end, find first remaining
     if(next >= TARGET_TOTAL){
       next = game.perItemState.findIndex(s => !s.done);
     }
     game.orderIndex = next;
     renderShelf();
     renderStatus();
   }


   function endGame(){
     const win = game.firstTryCorrectCount >= WIN_THRESHOLD;
     const title = win ? 'Bra jobbat, du vann!' : 'Bra försök! Spela igen för att öva mer.';
     const msg = `Rätt: <strong>${game.firstTryCorrectCount}</strong> av ${TARGET_TOTAL}.`;
     openEndModal(title, msg, win);
   }

      // ---------------------------------------------
      // POPUPS (toasts + modal)
      // ---------------------------------------------
      function toast(html, type='success', duration=4000){
        const el = document.createElement('div');
        el.className = 'toast ' + (type === 'error' ? 'error' : 'success');
        el.setAttribute('role', 'status');
        el.setAttribute('aria-live', 'polite');

        const content = document.createElement('div');
        content.className = 'content';
        content.innerHTML = html;

        const x = document.createElement('button');
        x.className = 'x';
        x.type = 'button';
        x.innerHTML = '×';
        x.setAttribute('aria-label', 'Stäng meddelande');

        el.append(content, x);
        toastsEl.appendChild(el);

        // timer with hover pause
        let remaining = duration;
        let start = Date.now();
        let timerId = setTimeout(close, remaining);

        function pause(){ clearTimeout(timerId); remaining -= Date.now() - start; }
        function resume(){ start = Date.now(); clearTimeout(timerId); timerId = setTimeout(close, Math.max(0, remaining)); }

        el.addEventListener('mouseenter', pause);
        el.addEventListener('mouseleave', resume);

        x.addEventListener('click', () => { clearTimeout(timerId); close(); });

        document.addEventListener('keydown', onKeydown);
        function onKeydown(e){
          if(e.key === 'Escape' && toastsEl.lastElementChild === el){
            clearTimeout(timerId);
            close();
          }
        }

        function close(){
          el.classList.add('is-hiding');
          el.addEventListener('transitionend', removeNow, { once:true });
          setTimeout(removeNow, 300);
        }
        function removeNow(){
          el.removeEventListener('mouseenter', pause);
          el.removeEventListener('mouseleave', resume);
          document.removeEventListener('keydown', onKeydown);
          if (el.parentNode) el.parentNode.removeChild(el);
        }

        return el;
      }

      function openEndModal(title, message){
        document.getElementById('endTitle').textContent = title;
        endMsg.innerHTML = message;
        endModal.classList.add('open');
        document.getElementById('btnPlayAgain').focus();
      }

      document.getElementById('btnPlayAgain').addEventListener('click', () => {
        endModal.classList.remove('open');
        Game.reset(); // restart with same words by default
      });

      // ---------------------------------------------
      // CORE LOGIC (no UI rendering beyond counters/toasts/modal)
      // ---------------------------------------------
      function start({ words=null, total=TARGET_TOTAL, threshold=0.8 } = {}){
        const picked = words && words.length
          ? words.slice(0, total)
          : pickRandom(FOOD_BANK, total);

        game = {
          words: picked,              // [{id, sv}, ...]
          total,
          winThreshold: Math.ceil(total * threshold),
          orderIndex: 0,
          perItemState: picked.map(w => ({ id:w.id, firstTry:true, done:false })),
          firstTryCorrectCount: 0,
          mistakes: 0,
          completed: 0
        };
        renderStatus();
      }

      function pick(pickedId){
        if(!game) return;

        const ix = game.orderIndex;
        const current = game.words[ix];
        const st = game.perItemState[ix];
        const correct = pickedId === current.id;

        if(correct){
          toast(`Bra jobbat, du hittade <strong>${current.sv}</strong>`, 'success');
          if(st.firstTry) game.firstTryCorrectCount += 1;
          st.done = true;
          game.completed += 1;
          nextItem();
        } else {
          toast('Försök igen!', 'error');
          if(st.firstTry){
            st.firstTry = false;
            game.mistakes += 1;
          } else {
            game.mistakes += 1;
          }
        }
        renderStatus();
      }

      function nextItem(){
        if(game.completed >= game.total){
          const win = game.firstTryCorrectCount >= game.winThreshold;
          const title = win ? 'Bra jobbat, du vann!' : 'Bra försök! Spela igen för att öva mer.';
          const msg = `Rätt: <strong>${game.firstTryCorrectCount}</strong> av ${game.total}.`;
          openEndModal(title, msg);
          return;
        }
        // advance to next not-done index
        let next = game.orderIndex + 1;
        while(next < game.total && game.perItemState[next].done){ next++; }
        if(next >= game.total){
          next = game.perItemState.findIndex(s => !s.done);
        }
        game.orderIndex = next;
      }

      function reset(){
        // restart same word set (no new sampling)
        if(!game){ start(); return; }
        const words = game.words.slice();
        start({ words, total: game.total, threshold: game.winThreshold / game.total });
      }

      // Expose a tiny API
      const Game = {
        start, pick, reset,
        toast, // in case you need manual popups
        get state(){ return game; }
      };
      window.Game = Game;

      // Boot minimal demo so you can test counters & popups without UI.
      Game.start();

      // --- DEMO ONLY (remove these listeners if not needed) ---
      document.getElementById('demoCorrect').addEventListener('click', () => {
        // Simulate picking the current correct id
        const current = Game.state.words[Game.state.orderIndex];
        Game.pick(current.id);
      });
      document.getElementById('demoWrong').addEventListener('click', () => {
        Game.toast('Försök igen!', 'error');
        // Count as mistake against current item
        const st = Game.state.perItemState[Game.state.orderIndex];
        if(st.firstTry){
          st.firstTry = false;
          Game.state.mistakes += 1;
        } else {
          Game.state.mistakes += 1;
        }
        // Reflect in pills
        const { completed, total, firstTryCorrectCount, mistakes, winThreshold } = Game.state;
        progressPill.textContent = `${completed} / ${total} klara`;
        firstTryPill.textContent = `Rätt: ${firstTryCorrectCount}`;
        mistakesPill.textContent = `Misstag: ${mistakes}`;
        targetPill.textContent   = `Tröskel: ${winThreshold} / ${total}`;
      });
      document.getElementById('demoReset').addEventListener('click', () => Game.reset());
    })();


   // ---------------------------------------------
   // WIRES
   // ---------------------------------------------
   document.getElementById('btnReset').addEventListener('click', () => newGame(false));
   document.getElementById('btnNewList').addEventListener('click', () => newGame(true));


   // Boot
   newGame(true);
  </script>
</body>
</html>
